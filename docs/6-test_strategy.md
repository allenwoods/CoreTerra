# CoreTerra 项目测试与验收策略

## 1. 引言与核心目标

本测试策略文档是确保 CoreTerra 项目成功的战略性文件，其核心目标是为系统独特的混合持久化架构（Hybrid Persistence Architecture）建立一套全面且严格的验证标准。此举不仅是常规的质量保证活动，更是保障系统核心价值主张——“无可辩驳的可审计性 (unquestionable auditability)”——得以实现的战略基石。本策略旨在将质量验证内嵌于开发流程，主动规避数据损坏、审计日志不同步及未来 AI 模型被污染等高风险问题，确保系统的长期稳定与数据可信。

CoreTerra 的架构设计旨在兼顾高性能查询与不可变审计能力，其核心由三个关键部分构成：

* 真相源 (Source of Truth, SSOT): 每一个任务项都以独立的 MyST Markdown 文件形式存在，由强大的版本控制系统 Git 进行管理。此设计确保所有数据的变更历史都被完整、不可变地记录下来。
* 可搜索元数据索引 (Searchable Metadata Index, SMI): 一个轻量级的 SQLite 数据库，作为文件元数据的高性能查询层。它镜像了 MyST 文件头（Frontmatter）中的关键字段，旨在大幅提升前端界面的响应速度和数据筛选效率。
* 审计日志 (Audit Trail): Git 的提交历史记录本身就是一份天然的、不可篡改的审计日志。每一次状态变更都对应一次 Git 提交，git log 命令能够精确追溯任何一个任务从创建到归档的完整生命周期。

这种架构的数据一致性和审计能力至关重要，它不仅是保障系统长期可靠运行的基石，更是未来集成人工智能（AI）功能的前提。正如相关研究所强调的，高质量、结构化且具备清晰谱系（Lineage）的元数据是构建可信赖 AI 模型的基础。CoreTerra 通过 Git 对 tags 等关键字段的版本控制，提供了无可辩驳的数据谱系追踪能力。这确保了在未来微调 AI 分类模型时，我们可以精准地进行“数据筛选（Data Selection）”，从而构建出一个干净、可追溯且上下文丰富的数据集，最大化 AI 系统的准确性和可靠性。

为了系统性地验证这一架构的每一个环节，我们设计了一套分层测试策略，以确保从代码细节到用户完整工作流的质量都达到最高标准。

---

## 2. 测试分层策略

为全面覆盖 CoreTerra 系统的质量要求，我们将采用一套分层测试策略，包含单元测试、集成测试和端到端测试。这种方法能够以高效、低成本的方式，在不同粒度上验证系统的功能、性能和数据完整性，通过在早期阶段发现并隔离不同类型的风险，确保每一层级的质量都得到有效保障。

### 2.1. 单元测试 (Unit Testing): 数据模型完整性校验

此测试层的核心目标是在代码层面确保数据模型的健壮性、一致性和合规性，构筑抵御数据模型腐败的第一道防线。

我们的核心工具是 Pydantic。所有进出 FastAPI 后端 API 端点的数据，都必须通过严格定义的 Pydantic 模型进行强制校验。根据项目蓝图中定义的 To-Do Item Unified Schema，单元测试将重点验证以下几个方面：

- **数据类型验证**: 确保每个字段都符合预期的数据类型。例如，`priority` 字段必须是整数，任何非整数的输入都将被拒绝。
- **枚举值约束**: 对于状态等关键字段，其值必须严格限制在预定义的枚举集合内。例如，`status` 字段的值只能是 'inbox', 'active', 'completed', 'archived' 之一。
- **字段必填性**: 核心字段如 `title` 和 `user_id` 必须存在且不能为空，确保数据的基本完整性。

通过在 API 边界进行如此严格的校验，单元测试层能够有效防止任何格式错误、类型不符或逻辑不合规的数据进入系统内部，从而从源头上保障了数据质量。

### 2.2. 集成测试 (Integration Testing): 原子事务完整性验证

此测试层的核心目标是验证后端服务在处理创建（Create）、更新（Update）和删除（Delete）操作时，能否确保对文件系统和 SQLite 索引的更新具有原子性。本层测试旨在规避因部分操作失败而导致系统状态不一致的风险，即真相源（文件）与元数据索引（数据库）之间出现数据脱节。

集成测试的执行步骤设计如下：

1. **API 调用**: 测试脚本模拟客户端向 FastAPI 后端发送一个写操作请求，例如，向 `POST /tasks/` 发送一个创建新任务的请求。
2. **响应验证**: 断言 API 返回了正确的 HTTP 状态码（如 `201 Created`）和符合预期的响应体。
3. **状态验证**: 测试代码将直接连接并查询 SQLite 数据库，验证相应的元数据记录是否已被正确创建或更新。同时，检查服务器的文件系统，确认对应的 MyST Markdown 文件（例如 `{ID}.md`）是否已按预期生成或修改。

需要明确的是，此层测试 **刻意不验证 Git 提交**。其关注点在于验证 FastAPI 应用内部各组件（API 业务逻辑、文件 I/O、数据库操作）之间的协同工作是否正确无误，确保一个业务操作能够一致地反映在应用所管理的数据存储上。

### 2.3. 端到端测试 (End-to-End Testing): 完整工作流与审计日志验证

此测试层的核心目标是从最终用户的视角出发，模拟真实的使用场景，验证整个系统的业务流程是否符合预期。这是对 CoreTerra 核心价值——"无可辩驳的可审计性"——的最高标准检验，其直接目标是防范审计日志中断或失实的重大风险。

端到端（E2E）测试将通过自动化脚本驱动命令行界面（CLI）或 Web 用户界面（Web UI），执行完整的用户工作流，例如创建任务、更新状态、添加标签等。它将所有独立的系统组件（前端、后端API、文件系统、数据库、Git）串联起来进行综合性检验。这一层测试是下一节将要详细阐述的"第三重校验"核心验收标准的具体实施场景，确保了系统的最终交付成果完全符合设计初衷。

---

## 3. 核心验收标准："第三重校验" (The Third Check)

对于 CoreTerra 系统，任何写操作的成功标志，绝不仅仅是 API 返回一个 `200 OK` 或客户端界面显示成功提示。其最终的、不可动摇的成功标志，必须由底层的 Git 提交历史来证明。这是我们对系统"可审计性"承诺的基石，也是区分 CoreTerra 与传统任务管理系统的核心所在。

为此，我们正式定义"第三重校验"作为所有写操作的核心验收标准。在每一个端到端测试场景中，一个成功的写操作必须同时满足以下所有条件：

1. **客户端反馈正确 (Client Feedback)**: 客户端（无论是 CLI 还是 Web UI）必须接收到预期的成功响应。例如，在创建任务后，API 应返回 `201 Created` 状态码，并附带包含新任务ID和元数据的 JSON 对象。
2. **系统状态一致 (Consistent State)**: 变更必须正确反映在系统的可查询状态中。通过后续的读操作（例如，调用 `GET /tasks/` 或在UI上刷新列表），能够查询到刚刚变更后的数据，这证明了 SQLite 索引和文件系统已同步更新。
3. **审计日志生成 (Audit Trail Verification)**: 必须在测试脚本中执行 `git log -- {ID}.md` 命令，并断言一个新的、格式规范的 Git Commit 已经被创建。断言最新的 Git Commit 消息严格遵循 `"[ACTION]: [Task Title]"` 格式，其中 ACTION 必须是 'ADD', 'COMPLETE', 'UPDATE' 等预定义动词之一。这是完成事务的最终、不可协商的证明，确保了每一次变更都有据可查。

---

## 4. 关键测试场景示例 (Gherkin Scenarios)

本节将采用 Gherkin 语法来定义关键的、面向用户的测试场景。这种"假如-当-那么"（Given-When-Then）的格式，使其兼具技术精确性和业务可读性，确保了开发、测试和产品团队对系统行为有一致的理解。

### 4.1. 场景一：创建新任务

此场景验证了用户通过 CLI 创建一个新任务的完整流程，并应用了"第三重校验"标准。

```gherkin
特性: 任务创建
  为了管理工作，用户需要能够创建新的任务。

  场景: 用户通过 CLI 成功创建一个新任务
    假如 用户已通过认证，并且当前工作目录是一个有效的 CoreTerra 项目
    当 用户在终端执行命令 `cot add "设计新的API端点" --priority 4 --tag "backend"`
    那么 CLI 应该在标准输出中显示一条成功消息，并包含新任务的ID（例如 "COT-12345"）
    而且 当向 API 端点 `GET /tasks/` 发起请求时，返回的任务列表中应包含 ID 为 "COT-12345" 的任务，其 priority 为 4，tags 包含 "backend"
    而且 在项目的 Git 仓库中执行 `git log -- COT-12345.md` 命令，必须能找到一条最新的 commit，其 commit message 必须严格遵循 "ADD: 设计新的API端点" 的格式
```

### 4.2. 场景二：解决并发冲突

此场景基于系统的乐观锁机制，验证了当两个用户同时修改同一任务时，系统如何防止数据覆盖，确保审计日志的完整性。

```gherkin
特性: 并发控制
  为了保证数据一致性，系统必须能处理并发编辑冲突。

  场景: 用户A的更新因用户B的先行修改而被拒绝
    假如 系统中存在一个ID为 "COT-54321" 的任务，其 `updated_at` 时间戳为 "2025-11-10T10:00:00Z"
    而且 用户A（通过Web UI）已经加载了该任务的当前状态，并记录了其 `updated_at` 时间戳
    当 用户B（通过CLI）成功更新了该任务的状态为 "completed"，导致其 `updated_at` 时间戳变为 "2025-11-10T10:05:00Z"
    而且 用户A 稍后尝试使用其过时的 `updated_at` 时间戳 "2025-11-10T10:00:00Z" 来提交对该任务标题的修改
    那么 API 必须拒绝用户A的请求，并返回 `409 Conflict` 状态码
    而且 在项目的 Git 仓库中执行 `git log -- COT-54321.md` 命令，日志中应该只存在一条由用户B操作产生的 "COMPLETE" 类型的 commit，而不存在任何由用户A失败的尝试所产生的 commit
```


这些具体的场景构成了我们验收测试的核心部分，确保了系统的关键路径不仅功能正确，而且在并发和审计方面同样稳健。接下来，我们将讨论保障系统响应性的性能基准。

---

## 5. 性能基准

性能是保障 CoreTerra 用户体验的关键因素。由于前端界面依赖于基于 `updated_at` 时间戳的高效轮询（Polling）机制来与后端状态保持同步，过高的延迟将直接导致界面信息陈旧，破坏 CLI 与 Web UI 之间操作的流畅感。因此，我们必须为核心交互定义明确的性能基准，以确保轮询机制能够提供近乎实时的用户体验。

### 核心性能指标与验收标准

- **指标名称**: 端到端状态同步延迟 (End-to-End State Synchronization Latency)
- **测量路径**: 
  - **计时起点**: 用户在 CLI 中执行一个改变状态的命令（例如 `cot done COT-12345`）并按下回车键。
  - **计时终点**: 该任务的状态更新最终在 Web UI 界面上可见（例如，任务卡片从"Active"列移动到"Completed"列）。
- **验收标准**: 在标准网络环境下，最大可容忍延迟不得超过 **2秒**。此基准将在模拟标准网络延迟的受控环境中，针对包含 1,000 个任务项的基线数据集进行自动化测量。

### 延迟构成分析

这个 2 秒的窗口包含了整个系统的完整处理链路，具体包括：

1. CLI 客户端的命令解析与 API 请求发送时间。
2. FastAPI 后端的完整事务处理时间，包括：
   - MyST Markdown 文件的写入。
   - 本地 Git 仓库的暂存（stage）与提交（commit）。
   - SQLite 索引的更新。
3. API 将成功响应返回给 CLI 客户端的时间。
4. 前端 React 应用的一个或多个轮询周期（取决于操作完成时机）。
5. 前端接收到新数据后的状态更新与界面重渲染时间。

此基准的达成，将确保即使用户在 CLI 和 Web UI 之间频繁切换，也能获得流畅、一致的体验。