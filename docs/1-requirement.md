# 产品需求文档 (PRD): CoreTerra

## 简介与愿景

CoreTerra 是一款深度融合了 GTD (Getting Things Done) 高效工作流的团队协作系统，其核心流程遵循 C·O·R·E 模型。它并非对现有工具的简单模仿，而是一次架构层面的革新。其战略定位是利用 Git 和纯文本文件作为底层基础设施，为技术与非技术团队提供一个完全透明、可审计且面向未来的工作流管理解决方案。

当今团队面临的核心痛点在于，传统任务管理工具虽然功能丰富，但在数据所有权、版本控制和与新兴AI技术集成方面存在根本性的局限。用户的宝贵数据被锁定在专有格式和云端孤岛中，历史变更难以追溯，且非结构化的数据格式使得与大语言模型（LLM）的高效交互成为挑战。CoreTerra 的独特价值主张正是为了解决这些问题：通过将每一个任务、每一个项目都结构化为纯文本（MyST Markdown）文件，并由 Git 进行版本控制，我们赋予团队前所未有的能力：完全的数据可控性、一条由 Git 提交记录构成的不可变历史追溯链 (Git Audit Trail)，以及一个为 AI/LLM 应用深度优化的原生数据格式。

为了实现这一愿景，我们必须首先理解并服务于系统中最关键的参与者——我们的用户。

## 1.0 用户画像与核心场景 (User Personas & Scenarios)

精确定义用户画像是 CoreTerra 成功的基石。产品的架构必须能够同时服务于光谱两端的两类核心用户：追求极致效率、生活在终端中的“命令行原生极客”，以及依赖直观视觉反馈、习惯图形界面的“Web图形界面用户”。只有同时满足这两种截然不同的交互范式，CoreTerra 才能真正覆盖整个团队的协作需求，实现工具的广泛采纳和高效协同。

CLI Power User (命令行高级用户)	Web GUI User (图形界面用户)
角色描述: 开发者、DevOps工程师或技术型项目经理。他们是效率的极致追求者，希望将任务管理无缝集成到现有的自动化脚本和CI/CD流水线中，信奉“键盘优于鼠标”的哲学。	角色描述: 产品经理、设计师、市场营销或运营人员。他们依赖直观的视觉引导、清晰的信息层级和简单的交互来管理复杂的任务列表，推崇Asana、Notion等工具提供的可视化体验。
核心诉求: 可通过脚本控制的工作流、键盘优先的操作、避免不必要的UI干扰、精确控制每一个操作。	核心诉求: 结构清晰的任务列表、直观的看板视图、可视化的状态标签、清晰的导航以及简单的拖放交互。
痛点: 对传统Web工具中繁琐的点选操作和流程中断感到厌烦，认为图形界面降低了信息密度和操作效率。	痛点: 对纯命令行工具感到恐惧和效率低下，认为缺乏视觉反馈的界面难以管理复杂项目。

### 用户故事 (User Stories)

#### CLI Power User:

1. 作为一个DevOps工程师，我想要通过一条core add命令快速将一个告警信息记录到收件箱，以便于我在处理终端任务时不中断心流。
2. 作为一个后端开发者，我想要编写一个Shell脚本，在Git提交后自动查询所有关联到Engineering角色的高优任务，以便于我能自动化地同步项目进度。
3. 作为一个技术负责人，我想要使用core list --status "completed" --role "Backend"命令快速生成上周已完成任务的报告，以便于我能高效地进行周报汇总。

#### Web GUI User:

1. 作为一个产品经理，我想要在看板视图中将一个“需求收集”卡片从inbox列拖动到active列，并为其分配Product-Management角色，以便于我能直观地更新任务状态。
2. 作为一个UI设计师，我想要通过可筛选的列表视图，一次性查看所有带有design和auth标签的任务，以便于我能快速聚焦于当前的设计冲刺。
3. 作为一个市场经理，我想要在任务详情页面通过点击日历控件为“发布会宣传稿”设置截止日期，以便于我能清晰地管理营销活动的时间线。

这两种用户画像的需求差异，直接决定了 CoreTerra 必须采用一种双模交互的架构设计，而支撑这两种交互模式的，则是我们统一且规范的核心工作流。

## 2.0 核心工作流：C·O·R·E 状态流转模型

C·O·R·E 工作流（Capture, Clarify, Organize, Review, Engage）是 CoreTerra 系统的核心骨架，其设计思想源自经典的 GTD 理论。该模型定义了系统内所有任务从诞生到归档的唯一生命周期路径，确保了无论是通过命令行还是Web界面操作，任务处理都遵循一致、系统且无歧义的规则。

### 2.1 Capture (捕获)

- **定义**: 这是所有想法、需求和待办事项的唯一入口。任何新创建的条目，无论多么模糊或微小，其初始状态都必须是inbox。此阶段的核心原则是"捕获一切，而非整理"，旨在清空大脑，将所有"开放循环"转移至可信的外部系统中。
- **产出**: 状态为 inbox 的任务项。

### 2.2 Clarify (明确)

- **定义**: 此阶段的目标是处理inbox中的每一个条目，将其转化为清晰、可执行的下一步行动。用户需要明确："这是什么？它是否可执行？"
- **规则**:
  - 如果一个条目需要多于一个步骤才能完成，它将被定义为一个Project。
  - 如果一个条目是信息而非任务，它将不可执行，应被赋予 "reference" 标签，并将其状态变更为 archived。
- **产出**: 对任务性质（单步任务、项目、参考资料）的明确判断。

### 2.3 Organize (组织)

- **定义**: 将已经明确化的任务分配到正确的"容器"中，并为其添加必要的上下文元数据。
- **规则**:
  - **强制关联角色 (Role)**: 每个任务都必须被强制关联到一个Role。Role在此系统中等同于GTD中的"关注领域"（Areas of Focus），它代表了用户承担的不同职责或关注的生活/工作领域（如"产品管理"、"家庭财务"）。
  - **元数据赋予**: 任务被赋予优先级（priority）、截止日期（due_date）、标签（tags）等关键元数据。
  - **状态变更**: 完成上述操作后，任务状态从inbox流转至 next (Next Actions) 或 waiting (Waiting For)。
- **产出**: 状态为 next 或 waiting，且包含完整元数据的可执行任务。

### 2.4 Review (回顾)

- **定义**: 这是定期检视整个系统的过程，确保所有任务都处于正确的状态，优先级仍然有效，并且系统整体保持清晰和可信。

### 2.5 Engage (执行)

- **定义**: 这是用户实际执行active状态任务的阶段。任务一旦完成，其状态应流转至completed (done)。最终，已完成的任务可以被归档，状态变为archived，以保持工作区的整洁。
- **产出**: 状态为 done 或 archived 的任务。

C·O·R·E 模型为系统提供了一个结构化的流程骨架。接下来的功能需求，便是实现这一流程并服务于我们两种核心用户的具体体现。

## 3.0 功能需求 (Functional Requirements)

本节将详细定义实现 C·O·R·E 工作流所需的关键功能。我们的核心验收标准是：每一个功能都必须同时提供对等的 CLI 和 Web 两种交互方式，以无差别地满足双用户画像的需求，确保体验的一致性和系统的完整性。

### 3.1 任务创建 (Create)

- **3.1.1 描述**: 在 C·O·R·E 流程的 Capture 阶段，将一个新的想法或任务快速捕获到 inbox 中。
- **3.1.2 CLI 交互**: 我们遵循 '[cli] [verb] [object]' 的简洁结构，以优化高频操作的输入效率。
- **3.1.3 Web UI 交互**: 用户可在界面的任何位置通过一个常驻的快速输入框添加任务。同时，支持通过命令面板（Command Palette，Cmd+K）唤起输入框，以体现键盘优先的设计理念，服务于高级GUI用户。

### 3.2 任务处理 (Clarify & Organize)

- **3.2.1 描述**: 在 C·O·R·E 流程的 Clarify 和 Organize 阶段，将 inbox 中的模糊条目转化为结构化、可执行的任务，并为其分配角色和元数据。
- **3.2.2 强制性约束**: 一个任务从 inbox 状态迁移至 active 状态的唯一必要条件是必须为其分配一个 Role。此设计源于"基于角色的生产力"理念，确保每一个待办事项都有明确的归属和上下文，Role 即 GTD 理论中的"关注领域"。这一强制性约束是系统的核心设计之一，它避免了无主任务的产生，确保了每一份工作量都能被归因和审计，为后续的团队效能分析和资源规划提供了结构化数据基础。
- **3.2.3 CLI 交互**: 提供功能明确的命令来修改任务的各项元数据。
- **3.2.4 Web UI 交互**: 在任务详情页，用户可以通过下拉菜单选择 Role，通过标签输入框添加 tags，并通过日历控件设置 due_date。

### 3.3 任务查询与展示 (Read)

- **3.3.1 描述**: 在 C·O·R·E 流程的 Review 阶段，用户能够根据状态、角色、优先级等多种条件来过滤、排序和展示任务。
- **3.3.2 CLI 交互**: 提供强大的查询和排序参数。
- **3.3.3 Web UI 交互**: Web 界面必须提供至少两种核心视图：
  - **列表视图 (List View)**: 类似 HubSpot 或 Jira 的可定制化表格视图，支持用户自定义显示列、按列排序和多条件过滤。
  - **看板视图 (Kanban View)**: 以任务状态 (Inbox, Next, Waiting, Done) 或角色为列，用户可以通过拖放操作直观地管理任务。

### 3.4 任务状态更新 (Update)

- **3.4.1 描述**: 在 C·O·R·E 流程的 Engage 阶段，任务的生命周期状态发生流转，例如从未完成到完成。
- **3.4.2 CLI 交互**: 提供语义清晰、操作快捷的动词命令来改变状态。
- **3.4.3 Web UI 交互**: 用户可以通过多种方式更新状态：在看板视图中将卡片拖拽到"已完成"列；在列表视图中勾选任务前的复选框；或在任务详情页点击"完成"按钮。

以上功能需求构成了产品的核心用户体验。而支撑这些功能、并使 CoreTerra 真正与众不同的，是其底层的非功能性架构设计。

## 4.0 非功能性需求 (Non-Functional Requirements)

非功能性需求是 CoreTerra 的战略护城河，它们确保了系统的可审计性、可扩展性以及面向未来的 AI 集成能力，是区别于所有传统任务管理工具的关键所在。

### 4.1 数据可审计性 (Auditability)

- **4.1.1 需求**: 每一次对任务的创建、修改或状态变更都必须对应一次原子的 Git 提交（atomic Git commit）。此架构设计确保了所有操作都留有不可篡改的痕迹。
- **4.1.2 实现**: 每次提交都应包含结构化的、机器可读的提交信息，例如：`COMPLETE: COT-123 - 完成用户认证模块` 或 `UPDATE: COT-123 - 优先级从 3 调整为 5`。这不仅为人类提供了清晰的变更历史，更形成了一条完整的、不可篡改的"审计线索"，完美实现了 AI 系统所需的 lineage tracking (谱系追踪)，确保了每一项数据变更的起源、转换和依赖关系都有据可查。用户或系统管理员可以通过标准的 Git 命令，如 `git log COT-123.md`，精确地追溯单个任务从创建到完成的完整生命周期。

### 4.2 AI 可读性 (AI-Readiness)

- **4.2.1 需求**: 所有任务数据必须以 MyST Markdown 格式存储。任务的所有结构化元数据（如 id, status, role 等）必须在文件头部的 YAML Frontmatter 区域中进行定义。
- **4.2.2 实现**: 这种"元数据先行"的设计为下游的 LLM 应用提供了极致干净和结构化的上下文。当需要进行数据分析、报告生成或智能预测时，AI 模型可以直接解析 YAML 元数据进行精确的筛选、分类和聚合，而无需对大段的非结构化文本进行复杂的实体抽取和意图识别。这种方式极大地提高了 AI 处理任务数据的效率和准确性，为未来构建智能 Agent 或进行流程挖掘奠定了坚实的数据基础。

这些非功能性需求直接定义了 CoreTerra 的数据存储范式，其具体实现依赖于一个清晰且一致的数据模型。

## 5.0 数据模型与架构

一个清晰、一致的数据模型是实现 CoreTerra 所有功能与非功能性需求的基石。本节将精确定义任务数据的持久化格式及其在系统中的管理方式。

### 5.1 文件即真理之源 (Source of Truth)

系统的核心原则是：单个的 .md 文件是每个任务的唯一真理之源（Single Source of Truth, SSOT）。所有关于任务的状态和信息都最终以该文件的内容为准。

### 5.2 核心数据结构 (MyST Frontmatter)

以下表格定义了构成任务核心属性的 MyST Frontmatter 字段。

字段名	数据类型	描述与AI相关性	示例
id	String	任务的唯一标识符 (e.g., "COT-123")。作为文件名和Git追溯的关键。	COT-123
title	String	任务的标题，是AI进行摘要和分类的主要文本输入。	Implement user authentication endpoint
status	Enum	任务的当前状态 (inbox, next, waiting, done, archived)。是AI分析任务生命周期的核心字段。	next
role	String	任务所属的职责/关注领域。AI可利用此字段进行上下文分组。	Engineering
priority	Integer	优先级 (1-5)。AI可用于预测任务重要性或风险。	5
parent_id	String (Nullable)	可选，用于链接到父任务（项目），构建层级结构，为AI提供结构化上下文。	COT-110
created_at	DateTime	任务创建时间戳 (ISO 8601)。是追踪任务起源的关键元数据。	2025-10-26T10:00:00Z
updated_at	DateTime	任务最后更新时间戳 (ISO 8601)。用于同步和并发控制。	2025-10-26T11:30:00Z
tags	List[String]	标签列表。AI可用于主题建模和相似任务推荐。	["backend", "api", "auth"]
due_date	Date (Nullable)	截止日期。AI可用于预测延期风险。	2025-11-15
completed_at	DateTime (Nullable)	任务完成时间戳。AI可用于计算任务周期。	2025-11-10T16:45:00Z

关于 Project 的定义: 一个任务被视为一个 Project，当它作为其他任务的父任务时。这通过任务的 id 被其他任务的 parent_id 字段引用来表示。

### 5.3 文件体 (File Body)

Frontmatter 下方是标准的 Markdown 文件体。此区域用于存储任务的详细描述、备注、检查清单、相关链接等非结构化或半结构化内容。

### 5.4 架构设计：混合存储模型

CoreTerra 采用一种创新的混合存储模型以兼顾数据完整性和查询性能：

- **Git 仓库中的 MyST 文件 (SSOT)**: 作为不可变的真理之源。每一次变更都通过 Git 提交被记录下来，保证了数据的完整性和可审计性。
- **本地 SQLite 数据库 (Searchable Metadata Index)**: 仅作为元数据的快速查询索引。该数据库镜像了 MyST 文件 Frontmatter 中的关键字段。当 Web UI 需要加载任务列表或执行过滤操作时，它会查询这个高度优化的索引，从而避免了在每次请求时扫描和解析整个文件系统的巨大性能开销。数据写入时，系统保证先成功写入文件并完成 Git 提交，再更新 SQLite 索引，确保数据一致性。

## 结束语

CoreTerra 的架构（以 Git 为真理之源，SQLite 为索引）不仅是一项技术选择，更是一项战略决策。它通过将 Git 的版本控制能力与结构化纯文本的灵活性相结合，为团队协作带来了革命性的透明度和数据所有权。这种设计为未来解锁了超越简单任务管理的能力，例如自动化的流程挖掘、由 AI 驱动的项目预测，以及为整个组织构建一个完全可审计的知识与协作基础设施。
